<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agora WebRTC Test ‚Äî Unobfuscated Audience Client</title>
    <style>
      :root {
        --bg: #0f1117;
        --surface: #1a1d27;
        --border: #2a2d3a;
        --text: #e1e4ed;
        --text-dim: #8b8fa3;
        --accent: #6c5ce7;
        --success: #00b894;
        --warn: #fdcb6e;
        --error: #e17055;
        --info: #74b9ff;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family:
          "Inter",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        padding: 20px;
      }
      h1 {
        font-size: 1.4rem;
        margin-bottom: 16px;
        color: var(--accent);
        display: flex;
        align-items: center;
        gap: 10px;
      }
      h1 span {
        font-size: 0.75rem;
        color: var(--text-dim);
        font-weight: 400;
      }

      .grid {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 16px;
        height: calc(100vh - 80px);
      }
      .panel {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 16px;
        overflow-y: auto;
      }
      .panel h2 {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-dim);
        margin-bottom: 12px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 8px;
      }

      /* Form */
      .field {
        margin-bottom: 10px;
      }
      .field label {
        display: block;
        font-size: 0.75rem;
        color: var(--text-dim);
        margin-bottom: 4px;
      }
      .field input,
      .field textarea {
        width: 100%;
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        padding: 8px 10px;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", "Fira Code", monospace;
      }
      .field input:focus,
      .field textarea:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Buttons */
      .btn-row {
        display: flex;
        gap: 8px;
        margin: 12px 0;
      }
      button {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        font-size: 0.8rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s;
      }
      .btn-connect {
        background: var(--accent);
        color: white;
        flex: 1;
      }
      .btn-connect:hover {
        filter: brightness(1.15);
      }
      .btn-connect:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn-disconnect {
        background: var(--error);
        color: white;
      }
      .btn-disconnect:hover {
        filter: brightness(1.15);
      }
      .btn-disconnect:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Status */
      .status-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
        margin-bottom: 12px;
      }
      .status-item {
        background: var(--bg);
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 0.72rem;
      }
      .status-item .label {
        color: var(--text-dim);
      }
      .status-item .value {
        font-family: monospace;
        font-weight: 600;
        margin-top: 2px;
      }
      .value.new {
        color: var(--info);
      }
      .value.checking,
      .value.connecting {
        color: var(--warn);
      }
      .value.connected {
        color: var(--success);
      }
      .value.failed,
      .value.disconnected,
      .value.closed {
        color: var(--error);
      }

      /* Video */
      .video-container {
        background: #000;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 12px;
        aspect-ratio: 4/3;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }
      .video-container video {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      .video-overlay {
        position: absolute;
        color: var(--text-dim);
        font-size: 0.85rem;
      }

      /* Log */
      #log {
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 0.72rem;
        line-height: 1.5;
        white-space: pre-wrap;
        word-break: break-all;
        padding: 8px;
        background: var(--bg);
        border-radius: 6px;
        height: calc(100% - 40px);
        overflow-y: auto;
      }
      .log-api {
        color: var(--info);
      }
      .log-ws {
        color: #a29bfe;
      }
      .log-pc {
        color: var(--success);
      }
      .log-dtls {
        color: var(--warn);
      }
      .log-sub {
        color: #fd79a8;
      }
      .log-video {
        color: #55efc4;
      }
      .log-err {
        color: var(--error);
      }
      .log-info {
        color: var(--text-dim);
      }

      /* Collapsible */
      details {
        margin: 8px 0;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
      }
      details summary {
        padding: 8px 10px;
        font-size: 0.75rem;
        cursor: pointer;
        background: var(--bg);
        color: var(--text-dim);
      }
      details pre {
        padding: 8px;
        font-size: 0.7rem;
        max-height: 300px;
        overflow: auto;
        background: var(--surface);
        white-space: pre-wrap;
        word-break: break-all;
      }
    </style>
  </head>
  <body>
    <h1>
      üõ∞Ô∏è Agora WebRTC Test
      <span>Unobfuscated Audience Client ‚Äî mirrors agora_ws.js flow</span>
    </h1>

    <div class="grid">
      <!-- Left panel: config + status -->
      <div class="panel">
        <h2>Connection Config</h2>

        <div class="field">
          <label>App ID</label>
          <input
            id="appId"
            placeholder="e.g. aab8b8f5a8cd4469a63042fcfafe7063"
          />
        </div>
        <div class="field">
          <label>Channel Name</label>
          <input
            id="channelName"
            placeholder="e.g. VIfnsgIQCmHqn4IXXWkQ000000"
          />
        </div>
        <div class="field">
          <label>Token</label>
          <textarea
            id="token"
            rows="3"
            placeholder="Agora token (from stream subscription response)"
          ></textarea>
        </div>
        <div class="field">
          <label>UID (0 = auto-assign)</label>
          <input id="uid" type="number" value="0" />
        </div>

        <div class="btn-row">
          <button class="btn-connect" id="btnConnect" onclick="startConnect()">
            Connect (Raw WS)
          </button>
          <button
            class="btn-connect"
            id="btnConnectSdk"
            onclick="startConnectSdk()"
            style="background: #2563eb"
          >
            Connect (SDK)
          </button>
          <button
            class="btn-disconnect"
            id="btnDisconnect"
            onclick="doDisconnect()"
            disabled
          >
            Disconnect
          </button>
        </div>

        <h2>Connection State</h2>
        <div class="status-grid">
          <div class="status-item">
            <div class="label">ICE</div>
            <div class="value" id="stIce">‚Äî</div>
          </div>
          <div class="status-item">
            <div class="label">DTLS</div>
            <div class="value" id="stDtls">‚Äî</div>
          </div>
          <div class="status-item">
            <div class="label">Signaling</div>
            <div class="value" id="stSignal">‚Äî</div>
          </div>
          <div class="status-item">
            <div class="label">Connection</div>
            <div class="value" id="stConn">‚Äî</div>
          </div>
        </div>

        <h2>Video</h2>
        <div class="video-container">
          <video id="remoteVideo" autoplay playsinline></video>
          <div
            id="sdkVideoContainer"
            style="
              width: 100%;
              height: 100%;
              position: absolute;
              top: 0;
              left: 0;
              display: none;
            "
          ></div>
          <div class="video-overlay" id="videoOverlay">No video stream</div>
        </div>

        <details id="detailOffer">
          <summary>Local Offer SDP</summary>
          <pre id="offerSdp">‚Äî</pre>
        </details>
        <details id="detailAnswer">
          <summary>Remote Answer SDP</summary>
          <pre id="answerSdp">‚Äî</pre>
        </details>
        <details id="detailOrtc">
          <summary>ORTC Parameters (from join_success)</summary>
          <pre id="ortcParams">‚Äî</pre>
        </details>
      </div>

      <!-- Right panel: log -->
      <div class="panel">
        <h2>Event Log</h2>
        <div id="log"></div>
      </div>
    </div>

    <script>
      // ============================================================
      // Agora WebRTC Unobfuscated Audience Client
      // Mirrors the flow from agora_ws.js P2PConnection + signal
      // ============================================================

      const AGORA_API_URLS = [
        "https://webrtc2-ap-web-1.agora.io/api/v2/transpond/webrtc?v=2",
        "https://webrtc2-ap-web-2.agora.io/api/v2/transpond/webrtc?v=2",
      ];

      // Global state
      let pc = null; // RTCPeerConnection
      let ws = null; // WebSocket
      let initialOffer = null;
      let localCapabilities = null;
      let remoteSDP = null;
      let assignedUid = null;
      let joinedChannel = null;
      let cname = null;
      let rejoinToken = null; // Token for rejoin_v3 on reconnect
      let pingInterval = null; // Ping-pong keepalive timer (3s)
      let joinSessionId = null; // Session ID from join
      let joinCid = null; // Channel ID from join response
      let joinVid = null; // VID from join response
      let agoraClient = null; // Agora SDK client (for SDK mode)
      let sdkMode = false; // Whether using SDK mode
      let onlineUsers = new Set(); // Track online user UIDs
      let pendingStreams = {}; // Track video streams pending subscription { uid: { ssrcId, rtxSsrcId, cname, subscribed } }

      // ---- Logging ----
      function log(tag, msg, cls) {
        const el = document.getElementById("log");
        const ts = new Date().toLocaleTimeString("en-GB", {
          hour12: false,
          fractionalSecondDigits: 3,
        });
        const line = document.createElement("div");
        line.className = cls || "log-info";
        line.textContent = `${ts} [${tag}] ${msg}`;
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
      }

      function setStatus(id, val) {
        const el = document.getElementById(id);
        el.textContent = val;
        el.className = "value " + val.toLowerCase().replace(/[^a-z]/g, "");
      }

      // ---- Crypto: derive_password (SHA-256 of uid string) ----
      async function derivePassword(uid) {
        const encoder = new TextEncoder();
        const data = encoder.encode(String(uid));
        const hash = await crypto.subtle.digest("SHA-256", data);
        return Array.from(new Uint8Array(hash))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }

      // ---- SDP parsing utilities ----
      function getOrtc(sdp) {
        // Helper to parse key-value parameters (e.g., fmtp)
        function parseParams(str) {
          const params = {};
          str.split(";").forEach((pair) => {
            const [k, v] = pair.split("=");
            if (k) params[k.trim()] = v ? v.trim() : null;
          });
          return params;
        }

        // Helper to check if a codec can be sent (logic inferred from SDK/ORTC analysis)
        function canSend(codec) {
          const name = codec.rtpMap.encodingName.toUpperCase();
          const params =
            codec.fmtp && codec.fmtp.parameters ? codec.fmtp.parameters : {};

          if (name === "H265") return false;
          if (name === "VP9") {
            // Profile 0 and 2 are sendable, 1 and 3 are not
            if (params["profile-id"] === "1" || params["profile-id"] === "3")
              return false;
          }
          if (name === "AV1") {
            // Profile 1 is recv only
            if (params["profile"] === "1") return false;
          }
          return true;
        }

        const lines = sdp
          .replace(/\r\n/g, "\n")
          .split("\n")
          .map((l) => l.trim());

        // Global parameters
        let iceUfrag = "";
        let icePwd = "";
        let fingerprint = null;

        // Media sections
        const mediaSections = []; // { type: 'audio'|'video', codecs: [], extensions: [], payloadTypes: [] }
        let currentSection = null;

        for (const line of lines) {
          if (line.startsWith("a=ice-ufrag:")) iceUfrag = line.split(":")[1];
          if (line.startsWith("a=ice-pwd:")) icePwd = line.split(":")[1];
          if (line.startsWith("a=fingerprint:")) {
            const parts = line.substring("a=fingerprint:".length).split(" ");
            fingerprint = { hashFunction: parts[0], fingerprint: parts[1] };
          }

          if (line.startsWith("m=")) {
            const parts = line.split(" ");
            const type = parts[0].split("=")[1]; // m=video -> video
            currentSection = {
              type,
              codecs: [],
              extensions: [],
              payloadTypes: parts.slice(3).map(Number),
            };
            mediaSections.push(currentSection);
          }

          if (!currentSection) continue;

          if (line.startsWith("a=rtpmap:")) {
            const match = line.match(
              /a=rtpmap:(\d+) ([^/]+)\/(\d+)(?:\/(\d+))?/,
            );
            if (match) {
              const pt = parseInt(match[1]);
              const name = match[2];
              const clock = parseInt(match[3]);
              const channels = match[4] ? parseInt(match[4]) : undefined;

              // Only parse if this PT is in the m= line definition
              if (currentSection.payloadTypes.includes(pt)) {
                let codec = currentSection.codecs.find(
                  (c) => c.payloadType === pt,
                );
                if (!codec) {
                  codec = {
                    payloadType: pt,
                    rtpMap: {},
                    rtcpFeedbacks: [],
                    fmtp: {},
                  };
                  currentSection.codecs.push(codec);
                }
                codec.rtpMap = { encodingName: name, clockRate: clock };
                if (channels) codec.rtpMap.encodingParameters = channels;
              }
            }
          }

          if (line.startsWith("a=fmtp:")) {
            const match = line.match(/a=fmtp:(\d+) (.+)/);
            if (match) {
              const pt = parseInt(match[1]);
              const params = parseParams(match[2]);
              const codec = currentSection.codecs.find(
                (c) => c.payloadType === pt,
              );
              if (codec) {
                if (!codec.fmtp) codec.fmtp = {};
                codec.fmtp.parameters = params;
              }
            }
          }

          if (line.startsWith("a=rtcp-fb:")) {
            const match = line.match(/a=rtcp-fb:(\d+) ([^ ]+)(?: (.+))?/);
            if (match) {
              const pt = parseInt(match[1]);
              const type = match[2];
              const param = match[3];
              const codec = currentSection.codecs.find(
                (c) => c.payloadType === pt,
              );
              if (codec) {
                const fb = { type };
                if (param) fb.parameter = param;
                codec.rtcpFeedbacks.push(fb);
              }
            }
          }

          if (line.startsWith("a=extmap:")) {
            const match = line.match(/a=extmap:(\d+) (.+)/);
            if (match) {
              currentSection.extensions.push({
                entry: parseInt(match[1]),
                extensionName: match[2].trim(),
              });
            }
          }
        }

        // Post-processing to match SDK structure
        const caps = {
          send: {
            audioCodecs: [],
            audioExtensions: [],
            videoCodecs: [],
            videoExtensions: [],
          },
          recv: {
            audioCodecs: [],
            audioExtensions: [],
            videoCodecs: [],
            videoExtensions: [],
          },
          sendrecv: {
            audioCodecs: [],
            audioExtensions: [],
            videoCodecs: [],
            videoExtensions: [],
          },
        };

        mediaSections.forEach((section) => {
          section.codecs.forEach((codec) => {
            // Add forced rrtr feedback to all recv/sendrecv codecs if missing
            const hasRrtr = codec.rtcpFeedbacks.some(
              (fb) => fb.type === "rrtr",
            );
            if (!hasRrtr) {
              codec.rtcpFeedbacks.push({ type: "rrtr" });
            }

            const send = canSend(codec);
            const recv = true; // Assumption: browser can recv what it offers

            if (send && recv) {
              if (section.type === "audio")
                caps.sendrecv.audioCodecs.push(codec);
              else caps.sendrecv.videoCodecs.push(codec);
            } else if (recv) {
              if (section.type === "audio") caps.recv.audioCodecs.push(codec);
              else caps.recv.videoCodecs.push(codec);
            }
          });

          const targetExtensions = caps.sendrecv;
          if (section.type === "audio")
            targetExtensions.audioExtensions.push(...section.extensions);
          else targetExtensions.videoExtensions.push(...section.extensions);
        });

        return {
          iceParameters: {
            iceUfrag: iceUfrag,
            icePwd: icePwd,
          },
          dtlsParameters: {
            fingerprints: fingerprint ? [fingerprint] : [],
          },
          rtpCapabilities: caps,
          version: "2",
        };
      }

      // Build remote answer SDP from server ORTC params (mirrors RemoteSDP in agora_ws.js)
      function buildAnswerSdp(serverOrtc, localOffer) {
        const ice = serverOrtc.iceParameters || {};
        const dtls = serverOrtc.dtlsParameters || {};
        const caps = serverOrtc.rtpCapabilities || {};
        const sendrecv = caps.sendrecv || caps.send || {};
        const candidates = ice.candidates || [];
        const fingerprints = dtls.fingerprints || [];

        // Parse local offer to know media order and extensions
        const offerLines = localOffer.split("\n").map((l) => l.trim());
        const mediaSections = [];
        let currentSection = null;

        for (const line of offerLines) {
          if (line.startsWith("m=")) {
            if (currentSection) mediaSections.push(currentSection);
            currentSection = {
              type: line.startsWith("m=audio") ? "audio" : "video",
              lines: [line],
              mid: null,
              direction: "sendrecv",
              extensions: [],
            };
          } else if (currentSection) {
            currentSection.lines.push(line);
            if (line.startsWith("a=mid:"))
              currentSection.mid = line.split(":")[1];
            if (line.startsWith("a=sendonly"))
              currentSection.direction = "sendonly";
            if (line.startsWith("a=recvonly"))
              currentSection.direction = "recvonly";
            if (line.startsWith("a=extmap:")) {
              const match = line.match(/a=extmap:(\d+)\s+(.*)/);
              if (match)
                currentSection.extensions.push({
                  id: match[1],
                  uri: match[2].split(" ")[0],
                });
            }
          }
        }
        if (currentSection) mediaSections.push(currentSection);

        // Build BUNDLE mids
        const mids = mediaSections.map((s) => s.mid || "0").join(" ");

        // Fingerprint line
        let fpLine =
          "a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00";
        if (fingerprints.length > 0) {
          const fp = fingerprints[0];
          const algo = fp.algorithm || fp.hashFunction || "sha-256";
          fpLine = `a=fingerprint:${algo} ${fp.fingerprint}`;
        }

        // Candidate lines
        const candLines = candidates.map((c) => {
          const foundation = c.foundation || "candidate0";
          const protocol = c.protocol || c.transport || "udp";
          const priority = c.priority || 2103266323;
          const ip = c.ip || c.address || "";
          const port = c.port || 0;
          const type = c.type || "host";
          return `a=candidate:${foundation} 1 ${protocol} ${priority} ${ip} ${port} typ ${type}`;
        });

        // Select codecs for each media type from server capabilities
        const serverAudioCodecs = sendrecv.audioCodecs || [];
        const serverVideoCodecs = sendrecv.videoCodecs || [];
        const serverAudioExts = sendrecv.audioExtensions || [];
        const serverVideoExts = sendrecv.videoExtensions || [];

        const sdpLines = [
          "v=0",
          "o=- 0 0 IN IP4 127.0.0.1",
          "s=AgoraGateway",
          "t=0 0",
          `a=group:BUNDLE ${mids}`,
          "a=ice-lite",
          "a=extmap-allow-mixed",
          "a=msid-semantic: WMS",
        ];

        for (const section of mediaSections) {
          const isAudio = section.type === "audio";
          const codecs = isAudio ? serverAudioCodecs : serverVideoCodecs;
          const serverExts = isAudio ? serverAudioExts : serverVideoExts;

          // Answer direction: complement of offer direction
          let answerDir = "sendonly"; // if offer is recvonly, answer is sendonly
          if (section.direction === "sendonly") answerDir = "recvonly";
          if (section.direction === "sendrecv") answerDir = "sendrecv";
          if (section.direction === "inactive") answerDir = "inactive";

          const pts = codecs.map((c) => c.payloadType).join(" ");
          sdpLines.push(`m=${section.type} 9 UDP/TLS/RTP/SAVPF ${pts || "0"}`);
          sdpLines.push("c=IN IP4 127.0.0.1");
          sdpLines.push("a=rtcp:9 IN IP4 0.0.0.0");
          sdpLines.push(`a=ice-ufrag:${ice.iceUfrag || ""}`);
          sdpLines.push(`a=ice-pwd:${ice.icePwd || ""}`);
          sdpLines.push("a=ice-options:trickle");
          sdpLines.push(fpLine);
          sdpLines.push("a=setup:active"); // Agora gateway is passive (ice-lite), we are active

          sdpLines.push(`a=mid:${section.mid || "0"}`);

          // Add candidates
          candLines.forEach((cl) => sdpLines.push(cl));

          // Extensions: use offer's extension IDs for matching URIs
          const offerExtMap = {};
          section.extensions.forEach((e) => {
            offerExtMap[e.uri] = e.id;
          });

          for (const ext of serverExts) {
            const name = ext.extensionName || ext.uri;
            if (!name) continue;
            if (offerExtMap[name]) {
              sdpLines.push(`a=extmap:${offerExtMap[name]} ${name}`);
            }
          }

          sdpLines.push(`a=${answerDir}`);
          sdpLines.push("a=rtcp-mux");
          sdpLines.push("a=rtcp-rsize");

          // Codec lines
          for (const codec of codecs) {
            const pt = codec.payloadType;
            const rm = codec.rtpMap || {};
            const enc = rm.encodingName || "";
            const cr = rm.clockRate || 90000;
            const ep = rm.encodingParameters;
            sdpLines.push(
              ep
                ? `a=rtpmap:${pt} ${enc}/${cr}/${ep}`
                : `a=rtpmap:${pt} ${enc}/${cr}`,
            );

            // RTCP feedback
            for (const fb of codec.rtcpFeedbacks || []) {
              const p = fb.parameter ? ` ${fb.parameter}` : "";
              sdpLines.push(`a=rtcp-fb:${pt} ${fb.type}${p}`);
            }

            // fmtp
            const fmtp = codec.fmtp || {};
            const params = fmtp.parameters || {};
            if (enc.toLowerCase() === "opus") {
              params.stereo = "1";
              params["sprop-stereo"] = "1";
            }
            if (Object.keys(params).length) {
              const paramStr = Object.entries(params)
                .map(([k, v]) =>
                  v !== null && v !== undefined ? `${k}=${v}` : k,
                )
                .join(";");
              sdpLines.push(`a=fmtp:${pt} ${paramStr}`);
            }
          }
        }

        return sdpLines.join("\r\n") + "\r\n";
      }

      // Build answer SDP with receive m-line for subscription (mirrors RemoteSDP.receive)
      function buildAnswerSdpWithSubscription(
        currentAnswerSdp,
        ssrcId,
        rtxSsrcId,
        subscriptionCname,
        serverOrtc,
      ) {
        // Add a new video m-line with the received SSRC for the subscribed stream
        const ice = serverOrtc.iceParameters || {};
        const dtls = serverOrtc.dtlsParameters || {};
        const fingerprints = dtls.fingerprints || [];
        const candidates = ice.candidates || [];
        const caps = serverOrtc.rtpCapabilities || {};
        const sendrecv = caps.sendrecv || caps.send || {};
        const serverVideoCodecs = sendrecv.videoCodecs || [];

        let fpLine =
          "a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00";
        if (fingerprints.length > 0) {
          const fp = fingerprints[0];
          fpLine = `a=fingerprint:${fp.algorithm || fp.hashFunction || "sha-256"} ${fp.fingerprint}`;
        }

        const candLines = candidates.map((c) => {
          const foundation = c.foundation || "candidate0";
          const protocol = c.protocol || c.transport || "udp";
          const priority = c.priority || 2103266323;
          return `a=candidate:${foundation} 1 ${protocol} ${priority} ${c.ip || ""} ${c.port || 0} typ ${c.type || "host"}`;
        });

        // Count existing m-lines to get next mid
        const existingMids = (currentAnswerSdp.match(/a=mid:\d+/g) || [])
          .length;
        const newMid = existingMids;

        // Update BUNDLE group
        const lines = currentAnswerSdp.split("\r\n");
        const updatedLines = [];
        for (const line of lines) {
          if (line.startsWith("a=group:BUNDLE")) {
            updatedLines.push(line + " " + newMid);
          } else {
            updatedLines.push(line);
          }
        }

        // Remove trailing empty line to append new m-section
        while (
          updatedLines.length &&
          updatedLines[updatedLines.length - 1] === ""
        )
          updatedLines.pop();

        const pts = serverVideoCodecs.map((c) => c.payloadType).join(" ");
        updatedLines.push(`m=video 9 UDP/TLS/RTP/SAVPF ${pts || "0"}`);
        updatedLines.push("c=IN IP4 127.0.0.1");
        updatedLines.push("a=rtcp:9 IN IP4 0.0.0.0");
        updatedLines.push(`a=ice-ufrag:${ice.iceUfrag || ""}`);
        updatedLines.push(`a=ice-pwd:${ice.icePwd || ""}`);
        updatedLines.push("a=ice-options:trickle");
        updatedLines.push(fpLine);
        updatedLines.push("a=setup:active");
        updatedLines.push(`a=mid:${newMid}`);
        candLines.forEach((cl) => updatedLines.push(cl));
        updatedLines.push("a=recvonly");
        updatedLines.push("a=rtcp-mux");
        updatedLines.push("a=rtcp-rsize");

        // Add codec lines
        for (const codec of serverVideoCodecs) {
          const pt = codec.payloadType;
          const rm = codec.rtpMap || {};
          const enc = rm.encodingName || "";
          const cr = rm.clockRate || 90000;
          const ep = rm.encodingParameters;
          updatedLines.push(
            ep
              ? `a=rtpmap:${pt} ${enc}/${cr}/${ep}`
              : `a=rtpmap:${pt} ${enc}/${cr}`,
          );
          for (const fb of codec.rtcpFeedbacks || []) {
            const p = fb.parameter ? ` ${fb.parameter}` : "";
            updatedLines.push(`a=rtcp-fb:${pt} ${fb.type}${p}`);
          }
          const fmtp = codec.fmtp || {};
          const params = fmtp.parameters || {};
          if (Object.keys(params).length) {
            const paramStr = Object.entries(params)
              .map(([k, v]) =>
                v !== null && v !== undefined ? `${k}=${v}` : k,
              )
              .join(";");
            updatedLines.push(`a=fmtp:${pt} ${paramStr}`);
          }
        }

        // Add SSRC attributes for the stream
        if (ssrcId) {
          const cn = subscriptionCname || "agora";
          updatedLines.push(`a=ssrc:${ssrcId} cname:${cn}`);
          updatedLines.push(`a=ssrc:${ssrcId} msid:${cn} video-${ssrcId}`);
          updatedLines.push(`a=ssrc:${ssrcId} mslabel:${cn}`);
          updatedLines.push(`a=ssrc:${ssrcId} label:video-${ssrcId}`);

          if (rtxSsrcId) {
            updatedLines.push(`a=ssrc:${rtxSsrcId} cname:${cn}`);
            updatedLines.push(`a=ssrc-group:FID ${ssrcId} ${rtxSsrcId}`);
          }
        }

        updatedLines.push("");
        return updatedLines.join("\r\n");
      }

      // ---- Step 1: Agora API Discovery ----
      async function agoraApiDiscovery(appId, channelName, token, uid) {
        log("API", "Starting Agora API discovery...", "log-api");

        const sid = Math.random().toString(36).substring(2, 18).toUpperCase();
        const clientTs = Date.now();
        const opid = Math.floor(Math.random() * 1e12);

        const payload = {
          appid: appId,
          client_ts: clientTs,
          opid,
          sid,
          request_bodies: [
            {
              uri: 22,
              buffer: {
                cname: channelName,
                detail: { 11: "CN,GLOBAL", 17: "1", 22: "CN,GLOBAL" },
                key: token,
                service_ids: [11, 26],
                uid: uid,
              },
            },
          ],
        };

        log("API", `Request payload: sid=${sid}, uid=${uid}`, "log-api");

        for (const apiUrl of AGORA_API_URLS) {
          try {
            log("API", `Trying ${apiUrl}...`, "log-api");

            // Build multipart form body
            const boundary =
              "----AgoraFormBoundary" + Math.random().toString(36).substring(2);
            let body = `--${boundary}\r\n`;
            body += `Content-Disposition: form-data; name="request"\r\n\r\n`;
            body += JSON.stringify(payload);
            body += `\r\n--${boundary}--\r\n`;

            const resp = await fetch(apiUrl, {
              method: "POST",
              headers: {
                "Content-Type": `multipart/form-data; boundary=${boundary}`,
              },
              body,
            });

            if (!resp.ok) {
              log("API", `HTTP ${resp.status} from ${apiUrl}`, "log-err");
              continue;
            }

            const data = await resp.json();
            log("API", `Response received, parsing...`, "log-api");
            log(
              "API",
              `Response bodies: ${data.response_body?.length || 0}`,
              "log-api",
            );

            // Parse response
            const result = {
              gateways: [],
              turnServers: [],
              uid: 0,
              responses: {},
            };

            for (const rb of data.response_body || []) {
              const buffer = rb.buffer || {};
              const code = buffer.code;
              if (code !== 0) {
                log("API", `API error code: ${code}`, "log-err");
                continue;
              }

              const flag = buffer.flag || 0;
              const edges = buffer.edges_services || [];
              const detail = {
                ...(data.detail || {}),
                ...(buffer.detail || {}),
              };
              const ticket = buffer.cert || "";
              const respUid = buffer.uid || 0;
              const cid = buffer.cid || 0;
              const cname = buffer.cname || "";

              log(
                "API",
                `Flag=${flag}, uid=${respUid}, edges=${edges.length}, cid=${cid}`,
                "log-api",
              );

              // Parse fingerprints from detail[19]
              const fingerprints = [];
              if (detail["19"]) {
                detail["19"]
                  .split(";")
                  .filter((f) => f.trim())
                  .forEach((f) => fingerprints.push(f.trim()));
              }

              // Parse credentials ‚Äî match SDK dx() function at agoraRTC_N.js:23979-23980
              // The SDK checks three conditions:
              //   1. uid is truthy
              //   2. wN("ENCRYPT_PROXY_USERNAME_AND_PSW") is true (always true, default at line 11949)
              //   3. window.isSecureContext is true (true for HTTPS, false for http:// or file://)
              // If ALL conditions pass: username = uid.toString(), password = SHA-256(uid.toString())
              // If ANY condition fails: username = "test", password = "111111" (RN defaults line 11755-11774)
              let username, credentials;
              if (respUid && window.isSecureContext) {
                username = String(respUid);
                credentials = await derivePassword(respUid);
                log(
                  "API",
                  `TURN credentials: uid-derived (isSecureContext=true), username=${username}`,
                  "log-api",
                );
              } else {
                // Agora RN defaults ‚Äî used when isSecureContext=false or no uid
                username = "test";
                credentials = "111111";
                log(
                  "API",
                  `TURN credentials: RN defaults (isSecureContext=${window.isSecureContext}, uid=${respUid}), username=${username}`,
                  "log-api",
                );
              }

              const addresses = edges.map((e, i) => ({
                ip: e.ip,
                port: e.port,
                username,
                credentials,
                ticket,
                fingerprint: fingerprints[i] || null,
              }));

              result.responses[flag] = {
                code,
                flag,
                uid: respUid,
                cid,
                cname,
                ticket,
                detail,
                addresses,
                fingerprints,
              };

              if (flag === 4096) {
                result.gateways = addresses;
                result.uid = respUid;
                result.cid = cid;
                result.cname = cname;
                result.ticket = ticket;
                result.detail = detail;
                result.server_ts = data.enter_ts || Date.now();
                result.opid = data.opid || opid;

                addresses.forEach((a) =>
                  log("API", `Gateway: ${a.ip}:${a.port}`, "log-api"),
                );
              }
              if (flag === 4194310 || flag === 4194304 || flag === 1048576) {
                result.turnServers.push(...addresses);
                addresses.forEach((a) =>
                  log(
                    "API",
                    `TURN: ${a.ip}:${a.port} (flag=${flag})`,
                    "log-api",
                  ),
                );
              }
            }

            if (result.gateways.length === 0) {
              log("API", "No gateway addresses found!", "log-err");
              continue;
            }

            log(
              "API",
              `Discovery complete: ${result.gateways.length} gateways, ${result.turnServers.length} TURN servers, assigned uid=${result.uid}`,
              "log-api",
            );
            return result;
          } catch (err) {
            log("API", `Error: ${err.message}`, "log-err");
            continue;
          }
        }

        throw new Error("All Agora API servers failed");
      }

      // ---- Step 2: Create PeerConnection + initial offer ----
      async function setupPeerConnection(apiResult) {
        log("PC", "Creating RTCPeerConnection...", "log-pc");

        // Build ICE servers from TURN addresses
        // Mirrors turnServerConfigToIceServers (agoraRTC_N.js:30736-30758)
        // SDK uses e.udpport for UDP, e.tcpport for TCP, and e.password for credential
        // The dx() function (line 23974-23981) sets both tcpport and udpport to e.port
        // SDK defaults (RN): udpport=3478, tcpport=3433
        const iceServers = [];
        for (const turn of apiResult.turnServers) {
          const udpPort = turn.port; // SDK sets udpport = e.port in dx()
          const tcpPort = turn.port; // SDK sets tcpport = e.port in dx()
          const ipDashed = turn.ip.replace(/\./g, "-");

          // UDP TURN (matches SDK line 30744-30748)
          iceServers.push({
            urls: `turn:${turn.ip}:${udpPort}?transport=udp`,
            username: turn.username || "",
            credential: turn.credentials || "",
            credentialType: "password",
          });
          // TCP TURN (matches SDK line 30750-30754)
          iceServers.push({
            urls: `turn:${turn.ip}:${tcpPort}?transport=tcp`,
            username: turn.username || "",
            credential: turn.credentials || "",
            credentialType: "password",
          });
          // TLS TURN (matches SDK line 30739-30743, security mode)
          iceServers.push({
            urls: `turns:${ipDashed}.edge.agora.io:443?transport=tcp`,
            username: turn.username || "",
            credential: turn.credentials || "",
            credentialType: "password",
          });
        }

        // Also add gateway-derived TURN servers (matches SDK serversFromGateway)
        // agoraRTC_N.js:25523-25529: username=uid.toString(), password=token
        // ports = gateway port + 30
        for (const gw of apiResult.gateways) {
          const gwTurnPort = parseInt(gw.port) + 30;
          const token = document.getElementById("token").value.trim();
          const gwUsername = String(apiResult.uid);
          // UDP
          iceServers.push({
            urls: `turn:${gw.ip}:${gwTurnPort}?transport=udp`,
            username: gwUsername,
            credential: token,
            credentialType: "password",
          });
          // TCP
          iceServers.push({
            urls: `turn:${gw.ip}:${gwTurnPort}?transport=tcp`,
            username: gwUsername,
            credential: token,
            credentialType: "password",
          });
          // Also add gateway as STUN candidate
          iceServers.push({ urls: `stun:${gw.ip}:${gw.port}` });
        }

        log("PC", `ICE servers configured: ${iceServers.length}`, "log-pc");
        iceServers.forEach((s) =>
          log(
            "PC",
            `  ${Array.isArray(s.urls) ? s.urls[0] : s.urls} user=${s.username || "(none)"} cred=${s.credential ? s.credential.substring(0, 8) + "..." : "(none)"}`,
            "log-pc",
          ),
        );

        const config = {
          iceServers,
          iceTransportPolicy: "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require",
        };

        pc = new RTCPeerConnection(config);

        // Bind state events
        pc.oniceconnectionstatechange = () => {
          const state = pc.iceConnectionState;
          log("PC", `ICE connection state: ${state}`, "log-pc");
          setStatus("stIce", state);
        };
        pc.onconnectionstatechange = () => {
          const state = pc.connectionState;
          log("PC", `Connection state: ${state}`, "log-pc");
          setStatus("stConn", state);
        };
        pc.onsignalingstatechange = () => {
          log("PC", `Signaling state: ${pc.signalingState}`, "log-pc");
          setStatus("stSignal", pc.signalingState);
        };
        pc.onicegatheringstatechange = () => {
          log("PC", `ICE gathering state: ${pc.iceGatheringState}`, "log-pc");
        };
        pc.onicecandidate = (ev) => {
          if (ev.candidate) {
            log(
              "PC",
              `Local ICE candidate: ${ev.candidate.candidate.substring(0, 80)}...`,
              "log-pc",
            );
          } else {
            log("PC", "ICE gathering complete (null candidate)", "log-pc");
          }
        };
        pc.ontrack = (ev) => {
          log(
            "VIDEO",
            `Track received! kind=${ev.track.kind}, id=${ev.track.id}`,
            "log-video",
          );
          if (ev.track.kind === "video") {
            const video = document.getElementById("remoteVideo");
            video.srcObject = ev.streams[0] || new MediaStream([ev.track]);
            document.getElementById("videoOverlay").style.display = "none";
            log("VIDEO", "Video stream attached to player", "log-video");
          }
        };

        // Monitor DTLS state via SCTP/DTLS transport (Chrome-specific)
        const dtlsInterval = setInterval(() => {
          if (!pc) {
            clearInterval(dtlsInterval);
            return;
          }
          try {
            const senders = pc.getSenders();
            const receivers = pc.getReceivers();
            const transports = [...senders, ...receivers]
              .map((s) => s.transport)
              .filter(Boolean);
            if (transports.length > 0 && transports[0].iceTransport) {
              const dtlsState = transports[0].state;
              const iceState = transports[0].iceTransport.state;
              setStatus("stDtls", dtlsState || "‚Äî");
              if (dtlsState === "connected") {
                log("DTLS", "DTLS transport connected!", "log-dtls");
                clearInterval(dtlsInterval);
              } else if (dtlsState === "failed") {
                log("DTLS", "DTLS transport FAILED", "log-err");
                clearInterval(dtlsInterval);
              }
            }
          } catch (e) {
            /* transport not ready yet */
          }
        }, 500);

        // Add transceivers for receiving (mirrors establish())
        pc.addTransceiver("video", { direction: "recvonly" });
        pc.addTransceiver("audio", { direction: "recvonly" });
        log("PC", "Added video + audio transceivers (recvonly)", "log-pc");

        // Create initial offer
        const offer = await pc.createOffer();
        initialOffer = offer;
        log(
          "PC",
          `Initial offer created (${offer.sdp.length} bytes)`,
          "log-pc",
        );
        document.getElementById("offerSdp").textContent = offer.sdp;

        // Create dummy PC to probe capabilities similar to SDK
        // const dummyPc = new RTCPeerConnection();
        // dummyPc.addTransceiver("video", { direction: "sendonly" });
        // dummyPc.addTransceiver("audio", { direction: "sendonly" });
        // dummyPc.addTransceiver("video", { direction: "recvonly" });
        // dummyPc.addTransceiver("audio", { direction: "recvonly" });
        // const dummyOffer = await dummyPc.createOffer();
        // dummyPc.close();

        // Extract ORTC parts
        // const dummyOrtc = getOrtc(dummyOffer.sdp); // For capabilities
        const mainOrtc = getOrtc(offer.sdp); // For ICE/DTLS

        const ortc = {
          iceParameters: mainOrtc.iceParameters,
          dtlsParameters: mainOrtc.dtlsParameters,
          rtpCapabilities: mainOrtc.rtpCapabilities,
          version: "2",
        };

        localCapabilities = ortc;
        log(
          "PC",
          `ORTC extracted: ${ortc.rtpCapabilities.sendrecv.audioCodecs.length} audio codecs, ${ortc.rtpCapabilities.sendrecv.videoCodecs.length} video codecs`,
          "log-pc",
        );

        return ortc;
      }

      // ---- Step 3: WebSocket connect + join ----
      async function connectWebSocket(apiResult, ortc) {
        const gateways = apiResult.gateways || [];
        if (gateways.length === 0) {
          throw new Error("No gateway addresses available");
        }

        log(
          "WS",
          `Attempting connection to ${gateways.length} gateway(s)...`,
          "log-ws",
        );

        let wsInstance = null;
        let usedGateway = null;

        try {
          // Phase 1: Race standard ports
          log("WS", "Racing standard ports...", "log-ws");
          const standardTargets = gateways.map((gw) => ({
            url: `wss://${gw.ip.replace(/\./g, "-")}.edge.agora.io:${gw.port}`,
            gw,
          }));
          const winner = await raceConnections(standardTargets, 5000);
          wsInstance = winner.ws;
          usedGateway = winner.gw;
          log("WS", `‚úÖ Connected to ${winner.url}`, "log-ws");
        } catch (e) {
          log(
            "WS",
            "Standard ports failed/timed out, trying fallback tunneling...",
            "log-ws",
          );
          // Phase 2: Race fallback ports
          const fallbackTargets = gateways.map((gw) => {
            const fallbackPort = Number(gw.port) + 150;
            return {
              url: `wss://${gw.ip.replace(/\./g, "-")}.edge.agora.io/ws/?p=${fallbackPort}`,
              gw,
            };
          });
          try {
            const winner = await raceConnections(fallbackTargets, 10000);
            wsInstance = winner.ws;
            usedGateway = winner.gw;
            log("WS", `‚úÖ Connected via fallback ${winner.url}`, "log-ws");
          } catch (err) {
            throw new Error(
              "Failed to connect to any gateway (standard or fallback).",
            );
          }
        }

        ws = wsInstance; // Assign global

        // Perform Join
        log("WS", "Sending Join...", "log-ws");
        return await performJoin(ws, apiResult, ortc, usedGateway);
      }

      function raceConnections(targets, timeoutMs) {
        return new Promise((resolve, reject) => {
          let pending = targets.length;
          const sockets = [];
          let solved = false;

          const timer = setTimeout(() => {
            if (solved) return;
            solved = true;
            sockets.forEach((s) => s.close());
            reject(new Error("Connection race timeout"));
          }, timeoutMs);

          targets.forEach(({ url, gw }) => {
            const s = new WebSocket(url);
            sockets.push(s);
            s.binaryType = "arraybuffer";

            s.onopen = () => {
              if (solved) {
                s.close();
                return;
              }
              solved = true;
              clearTimeout(timer);
              // Close losers and cleanup winner
              sockets.forEach((other) => {
                if (other !== s) other.close();
              });
              s.onopen = null;
              s.onclose = null;
              s.onerror = null;
              resolve({ ws: s, url, gw });
            };

            const fail = () => {
              if (solved) return;
              pending--;
              if (pending === 0 && !solved) {
                solved = true;
                clearTimeout(timer);
                reject(new Error("All connections failed"));
              }
            };
            s.onerror = fail;
            s.onclose = fail;
          });
        });
      }

      // Helper function to perform Join on specified socket
      // (Replaces tryConnectToGateway)
      function performJoin(wsInstance, apiResult, ortc, gw) {
        return new Promise((resolve, reject) => {
          ws = wsInstance;
          const wsUrl = ws.url;

          // Build join_v3 message (mirrors getJoinMessage)

          // Build join_v3 message (mirrors getJoinMessage)
          const appId = document.getElementById("appId").value.trim();
          const channelName = document
            .getElementById("channelName")
            .value.trim();
          const token = document.getElementById("token").value.trim();
          const sessionId = crypto.randomUUID().replace(/-/g, "").toUpperCase();

          // Build ap_response from discovery response (mirrors to_ap_response)
          const gwResp = apiResult.responses[4096] || {};
          const apResponse = {
            code: gwResp.code || 0,
            server_ts: apiResult.server_ts || Date.now(),
            uid: apiResult.uid,
            cid: gwResp.cid || 0,
            cname: gwResp.cname || channelName,
            detail: gwResp.detail || {},
            flag: 4096,
            opid: apiResult.opid || 0,
            cert: gwResp.ticket || "",
            ticket: gwResp.ticket || "",
          };

          const joinMsg = {
            _id: Math.random().toString(36).substring(2, 8),
            _type: "join_v3",
            _message: {
              p2p_id: 1,
              session_id: sessionId,
              app_id: appId,
              channel_key: token,
              channel_name: channelName,
              sdk_version: "4.24.2",
              browser: navigator.userAgent,
              process_id: "process-" + crypto.randomUUID(),
              mode: "live",
              codec: "vp8",
              role: "host",
              has_changed_gateway: false,
              ap_response: apResponse,
              extend: "",
              details: {},
              features: { rejoin: true },
              attributes: {
                userAttributes: {
                  enableAudioMetadata: false,
                  enableAudioPts: false,
                  enablePublishedUserList: true,
                  maxSubscription: 50,
                  enableUserLicenseCheck: true,
                  enableVosFallback: false,
                  enableRTX: true,
                  enableInstantVideo: false,
                  enableDataStream2: false,
                  enableDualStreamFlag: false,
                  enableAutFeedback: true,
                  enableUserAutoRebalanceCheck: true,
                  enableXR: true,
                  enableLossbasedBwe: true,
                  enableNetworkQualityProbe: false,
                  enableAutCC: true,
                  enablePreallocPC: false,
                  enablePubTWCC: false,
                  enableQualityFallback: false,
                  enableSubTWCC: true,
                  enablePubRTX: true,
                  enableSubRTX: true,
                },
              },
              join_ts: Date.now(),
              ortc,
            },
          };

          log(
            "WS",
            `Sending join_v3 (session=${sessionId.substring(0, 8)}...)`,
            "log-ws",
          );
          ws.send(JSON.stringify(joinMsg));

          ws.onmessage = async (event) => {
            try {
              const msg = JSON.parse(event.data);
              const type = msg._type || "";
              const result = msg._result || "";
              const message = msg._message || {};

              log("WS", `‚Üê ${type || result} (id=${msg._id || "?"})`, "log-ws");

              // Join success
              if (result === "success" && message.ortc) {
                log("WS", "Join successful!", "log-ws");
                assignedUid = message.uid || apiResult.uid;
                joinedChannel = message.cname || "";

                // Store rejoin token for reconnection (mirrors agoraRTC_N.js)
                rejoinToken = message.rejoin_token || null;
                joinCid = message.cid || 0;
                joinVid = Number(message.vid || 0);
                if (rejoinToken) {
                  log(
                    "WS",
                    `Stored rejoin_token: ${rejoinToken.substring(0, 20)}...`,
                    "log-ws",
                  );
                }

                log(
                  "WS",
                  `Assigned UID: ${assignedUid}, channel: ${joinedChannel}`,
                  "log-ws",
                );

                const serverOrtc = message.ortc;
                document.getElementById("ortcParams").textContent =
                  JSON.stringify(serverOrtc, null, 2);
                log(
                  "WS",
                  `Server ORTC: ICE ufrag=${serverOrtc.iceParameters?.iceUfrag}, candidates=${serverOrtc.iceParameters?.candidates?.length || 0}`,
                  "log-ws",
                );
                log(
                  "WS",
                  `Server ORTC: DTLS fingerprints=${serverOrtc.dtlsParameters?.fingerprints?.length || 0}`,
                  "log-ws",
                );

                // Inject fingerprints from gateway addresses
                if (apiResult.gateways.length > 0) {
                  const dtlsParams = (serverOrtc.dtlsParameters =
                    serverOrtc.dtlsParameters || {});
                  const fps = (dtlsParams.fingerprints =
                    dtlsParams.fingerprints || []);
                  const seen = new Set(
                    fps.map((f) => (f.fingerprint || "").toLowerCase()),
                  );
                  for (const gw of apiResult.gateways) {
                    if (
                      gw.fingerprint &&
                      !seen.has(gw.fingerprint.toLowerCase())
                    ) {
                      let algo = "sha-256",
                        fpVal = gw.fingerprint;
                      if (fpVal.includes(" ")) {
                        const p = fpVal.split(" ");
                        algo = p[0];
                        fpVal = p[1];
                      }
                      fps.push({
                        hashFunction: algo,
                        algorithm: algo,
                        fingerprint: fpVal,
                      });
                      seen.add(fpVal.toLowerCase());
                      log(
                        "WS",
                        `Injected gateway fingerprint: ${fpVal.substring(0, 20)}...`,
                        "log-ws",
                      );
                    }
                  }
                }

                // ws.send(JSON.stringify(roleMsg));
                // log("WS", "Sent set_client_role (host)", "log-ws");

                // ---- Step 4: Set up PeerConnection with server ORTC ----
                await setupConnection(serverOrtc);

                // Start ping-pong keepalive (every 3s, matching Agora SDK)
                if (pingInterval) clearInterval(pingInterval);
                pingInterval = setInterval(() => {
                  if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(
                      JSON.stringify({
                        _id: Math.random().toString(36).substring(2, 8),
                        _type: "ping",
                      }),
                    );
                  }
                }, 3000);
                log(
                  "WS",
                  "Started ping-pong keepalive (3s interval)",
                  "log-ws",
                );

                resolve(serverOrtc);
              }

              // User online ‚Äî check if we have a pending video stream to subscribe to
              if (type === "on_user_online") {
                const onlineUid = message.uid;
                log("WS", `User online: uid=${onlineUid}`, "log-ws");
                onlineUsers.add(onlineUid);

                // If we already have a pending video stream for this user, subscribe now
                if (
                  pendingStreams[onlineUid] &&
                  !pendingStreams[onlineUid].subscribed
                ) {
                  const s = pendingStreams[onlineUid];
                  s.subscribed = true;
                  log(
                    "SUB",
                    `User ${onlineUid} is online and has pending video stream, subscribing now`,
                    "log-sub",
                  );
                  await subscribeToStream(
                    onlineUid,
                    s.ssrcId,
                    s.rtxSsrcId,
                    s.cname,
                  );
                }
              }

              // Video stream added ‚Äî store and subscribe if user is already online
              if (type === "on_add_video_stream") {
                const streamUid = message.uid;
                const ssrcId = message.ssrcId;
                const rtxSsrcId = message.rtxSsrcId;
                const streamCname = message.cname;
                log(
                  "SUB",
                  `Video stream added: uid=${streamUid}, ssrcId=${ssrcId}, rtxSsrcId=${rtxSsrcId}`,
                  "log-sub",
                );

                // Store the pending stream
                pendingStreams[streamUid] = {
                  ssrcId,
                  rtxSsrcId,
                  cname: streamCname,
                  subscribed: false,
                };

                // Only subscribe if the user is already online
                if (onlineUsers.has(streamUid)) {
                  pendingStreams[streamUid].subscribed = true;
                  log(
                    "SUB",
                    `User ${streamUid} already online, subscribing to video stream now`,
                    "log-sub",
                  );
                  await subscribeToStream(
                    streamUid,
                    ssrcId,
                    rtxSsrcId,
                    streamCname,
                  );
                } else {
                  log(
                    "SUB",
                    `User ${streamUid} not yet online, deferring subscribe until on_user_online`,
                    "log-sub",
                  );
                }
              }

              // User offline ‚Äî unsubscribe and clean up
              if (type === "on_user_offline") {
                const offlineUid = message.uid;
                const reason = message.reason || "unknown";
                log(
                  "WS",
                  `User offline: uid=${offlineUid}, reason=${reason}`,
                  "log-ws",
                );
                onlineUsers.delete(offlineUid);

                // Unsubscribe if we had an active subscription
                if (
                  pendingStreams[offlineUid] &&
                  pendingStreams[offlineUid].subscribed
                ) {
                  await unsubscribeFromStream(offlineUid);
                }
                delete pendingStreams[offlineUid];
              }

              // Audio stream added
              if (type === "on_add_audio_stream") {
                log(
                  "SUB",
                  `Audio stream added: uid=${message.uid}, ssrcId=${message.ssrcId}`,
                  "log-sub",
                );
              }

              // RTP capability change
              if (type === "on_rtp_capability_change") {
                log(
                  "WS",
                  `RTP capability change: video_codec=${JSON.stringify(message.video_codec)}`,
                  "log-ws",
                );
              }

              // Subscribe response
              if (type === "on_subscribe_success") {
                log(
                  "SUB",
                  `Subscribe success for stream ${message.stream_id}`,
                  "log-sub",
                );
              }

              // Mute/unmute
              if (type === "on_mute" || type === "on_unmute") {
                log(
                  "WS",
                  `${type}: uid=${message.uid}, ${message.audio ? "audio" : ""}${message.video ? "video" : ""}`,
                  "log-ws",
                );
              }

              // P2P lost
              if (type === "on_p2p_lost") {
                log(
                  "WS",
                  `P2P lost: ${message.error_str || "unknown"}`,
                  "log-err",
                );
              }

              // Token privilege will expire ‚Äî send renew_token
              if (type === "on_token_privilege_will_expire") {
                log("TOKEN", "‚ö†Ô∏è Token will expire soon!", "log-ws");
                const currentToken = document
                  .getElementById("token")
                  .value.trim();
                if (ws && ws.readyState === WebSocket.OPEN && currentToken) {
                  ws.send(
                    JSON.stringify({
                      _id: Math.random().toString(36).substring(2, 8),
                      _type: "renew_token",
                      _message: { token: currentToken },
                    }),
                  );
                  log("TOKEN", "Sent renew_token with current token", "log-ws");
                }
              }

              // Token privilege did expire
              if (type === "on_token_privilege_did_expire") {
                log(
                  "TOKEN",
                  "‚ùå Token expired! Update token field and reconnect.",
                  "log-err",
                );
              }

              // Ping response (no-op, just confirms keepalive)
              if (result === "success" && !message.ortc && msg._id) {
                // Ping-pong response, connection alive
              }

              // Error
              if (type === "error") {
                log("WS", `Error: ${JSON.stringify(message)}`, "log-err");
              }
            } catch (err) {
              log("WS", `Message parse error: ${err.message}`, "log-err");
            }
          };

          ws.onerror = (ev) => {
            log("WS", `WebSocket error`, "log-err");
            reject(new Error("WebSocket error"));
          };

          ws.onclose = (ev) => {
            log(
              "WS",
              `WebSocket closed: code=${ev.code}, reason=${ev.reason || "none"}`,
              "log-ws",
            );
          };
        });
      }

      // ---- Step 4: Set SDP on PeerConnection (mirrors P2PConnection.connect) ----
      async function setupConnection(serverOrtc) {
        log("PC", "Setting up SDP exchange...", "log-pc");

        // Build answer SDP from server ORTC
        const answerSdp = buildAnswerSdp(serverOrtc, initialOffer.sdp);
        log("PC", `Answer SDP built (${answerSdp.length} bytes)`, "log-pc");
        document.getElementById("answerSdp").textContent = answerSdp;

        // Store for later use in subscription
        remoteSDP = { sdp: answerSdp, serverOrtc };

        // Set local description (offer)
        await pc.setLocalDescription({ type: "offer", sdp: initialOffer.sdp });
        log("PC", "Set local description (offer)", "log-pc");

        // Set remote description (answer from server)
        await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });
        log("PC", "Set remote description (answer)", "log-pc");

        log(
          "PC",
          `ICE state: ${pc.iceConnectionState}, Connection: ${pc.connectionState}`,
          "log-pc",
        );
      }

      // ---- Step 5: Subscribe to video stream ----
      async function subscribeToStream(
        streamUid,
        ssrcId,
        rtxSsrcId,
        streamCname,
      ) {
        log("SUB", `Subscribing to stream uid=${streamUid}...`, "log-sub");

        // Send subscribe message ‚Äî the server starts sending media over
        // the already-negotiated DTLS/SRTP connection. No SDP renegotiation needed;
        // the initial offer already has a recvonly video transceiver.
        // pc.ontrack fires when media arrives.
        const subMsg = {
          _id: Math.random().toString(36).substring(2, 8),
          _type: "subscribe",
          _message: {
            stream_id: streamUid,
            stream_type: "video",
            mode: "live",
            codec: "vp8",
            p2p_id: 1,
            twcc: true,
            rtx: true,
            extend: "",
            ssrcId: ssrcId,
          },
        };

        ws.send(JSON.stringify(subMsg));
        log(
          "SUB",
          `Sent subscribe for uid=${streamUid}, ssrcId=${ssrcId}. Waiting for track via pc.ontrack...`,
          "log-sub",
        );
      }

      // ---- Step 6: Unsubscribe from video stream ----
      async function unsubscribeFromStream(streamUid) {
        log("SUB", `Unsubscribing from stream uid=${streamUid}...`, "log-sub");

        const unsubMsg = {
          _id: Math.random().toString(36).substring(2, 8),
          _type: "unsubscribe",
          _message: {
            p2p_id: 1,
            ortc: [],
            stream_id: streamUid,
          },
        };

        ws.send(JSON.stringify(unsubMsg));
        log("SUB", `Sent unsubscribe for uid=${streamUid}`, "log-sub");
      }

      // ---- Main flow ----
      async function startConnect() {
        const appId = document.getElementById("appId").value.trim();
        const channelName = document.getElementById("channelName").value.trim();
        const token = document.getElementById("token").value.trim();
        const uid = parseInt(document.getElementById("uid").value) || 0;

        if (!appId || !channelName || !token) {
          log(
            "ERR",
            "Please fill in App ID, Channel Name, and Token",
            "log-err",
          );
          return;
        }

        document.getElementById("btnConnect").disabled = true;
        document.getElementById("btnConnectSdk").disabled = true;
        document.getElementById("btnDisconnect").disabled = false;
        document.getElementById("log").innerHTML = "";

        try {
          // Step 1: API Discovery
          const apiResult = await agoraApiDiscovery(
            appId,
            channelName,
            token,
            uid,
          );

          // Step 2: Create PeerConnection + initial offer
          const ortc = await setupPeerConnection(apiResult);

          // Step 3: WebSocket connect + join (handles steps 4+5 via callbacks)
          await connectWebSocket(apiResult, ortc);

          log(
            "INFO",
            "‚úÖ Connection flow complete ‚Äî waiting for ICE/DTLS...",
            "log-info",
          );
        } catch (err) {
          log("ERR", `Connection failed: ${err.message}`, "log-err");
          console.error(err);
          document.getElementById("btnConnect").disabled = false;
        }
      }

      // ============================================================
      // SDK-based connection (mirrors agora-client.js)
      // Uses AgoraRTC.createClient ‚Äî SDK handles all WebRTC internally
      // ============================================================
      async function startConnectSdk() {
        const appId = document.getElementById("appId").value.trim();
        const channelName = document.getElementById("channelName").value.trim();
        const token = document.getElementById("token").value.trim() || null;
        const uid = parseInt(document.getElementById("uid").value) || 0;

        if (!appId || !channelName) {
          log("ERR", "App ID and Channel Name are required", "log-err");
          return;
        }

        document.getElementById("btnConnect").disabled = true;
        document.getElementById("btnConnectSdk").disabled = true;
        document.getElementById("btnDisconnect").disabled = false;
        sdkMode = true;

        try {
          // Load Agora SDK if not already loaded
          if (!window.AgoraRTC) {
            log("SDK", "Loading Agora RTC SDK...", "log-api");
            await new Promise((resolve, reject) => {
              const script = document.createElement("script");
              script.src =
                "https://download.agora.io/sdk/release/AgoraRTC_N.js";
              script.onload = resolve;
              script.onerror = () =>
                reject(new Error("Failed to load Agora SDK"));
              document.head.appendChild(script);
            });
            log("SDK", "Agora RTC SDK loaded", "log-api");
          }

          // Create client (same config as agora-client.js)
          const client = window.AgoraRTC.createClient({
            mode: "live",
            codec: "vp8",
            disableLog: false,
            enableLogUpload: false, // Disable log upload
            role: "host",
          });
          agoraClient = client;

          // Handle remote user publishing a track
          client.on("user-published", async (user, mediaType) => {
            log("SDK", `User ${user.uid} published ${mediaType}`, "log-video");
            await client.subscribe(user, mediaType);
            log("SDK", `Subscribed to ${user.uid} ${mediaType}`, "log-video");

            if (mediaType === "video") {
              const container = document.getElementById("sdkVideoContainer");
              container.style.display = "block";
              container.innerHTML = ""; // Clear previous
              document.getElementById("videoOverlay").style.display = "none";
              document.getElementById("remoteVideo").style.display = "none";

              // Create a div for the video and let SDK render into it
              const playerDiv = document.createElement("div");
              playerDiv.id = `player-${user.uid}`;
              playerDiv.style.width = "100%";
              playerDiv.style.height = "100%";
              container.appendChild(playerDiv);

              user.videoTrack.play(playerDiv);
              log("SDK", `Video playing for uid=${user.uid}`, "log-video");
            }
            if (mediaType === "audio") {
              user.audioTrack.play();
              log("SDK", `Audio playing for uid=${user.uid}`, "log-video");
            }
          });

          client.on("user-unpublished", (user, mediaType) => {
            log(
              "SDK",
              `User ${user.uid} unpublished ${mediaType}`,
              "log-video",
            );
            if (mediaType === "video") {
              const playerDiv = document.getElementById(`player-${user.uid}`);
              if (playerDiv) playerDiv.remove();
            }
          });

          client.on("user-joined", (user) => {
            log("SDK", `User ${user.uid} joined`, "log-ws");
          });

          client.on("user-left", (user) => {
            log("SDK", `User ${user.uid} left`, "log-ws");
          });

          client.on("connection-state-change", (cur, prev) => {
            log("SDK", `Connection: ${prev} ‚Üí ${cur}`, "log-pc");
            setStatus("stConn", cur);
            if (cur === "CONNECTED") {
              setStatus("stIce", "connected");
              setStatus("stSignal", "stable");
            }
          });

          client.on("token-privilege-will-expire", () => {
            log("SDK", "‚ö†Ô∏è Token will expire soon!", "log-ws");
          });

          client.on("token-privilege-did-expire", () => {
            log("SDK", "‚ùå Token expired!", "log-err");
          });

          // Set role to host (matching agora-client.js)
          client.setClientRole("host");

          log(
            "SDK",
            `Joining: appId=${appId}, channel=${channelName}, uid=${uid}`,
            "log-api",
          );
          const assignedUid = await client.join(
            appId,
            channelName,
            token,
            uid || null,
          );
          log("SDK", `Joined! Assigned UID: ${assignedUid}`, "log-ws");
          setStatus("stConn", "CONNECTED");
        } catch (err) {
          log("SDK", `Connection failed: ${err.message}`, "log-err");
          console.error(err);
          sdkMode = false;
          document.getElementById("btnConnect").disabled = false;
          document.getElementById("btnConnectSdk").disabled = false;
          document.getElementById("btnDisconnect").disabled = true;
        }
      }

      function doDisconnect() {
        log("INFO", "Disconnecting...", "log-info");

        // SDK mode cleanup
        if (sdkMode && agoraClient) {
          agoraClient.leave().catch((e) => console.warn("SDK leave error:", e));
          agoraClient = null;
          sdkMode = false;
          const container = document.getElementById("sdkVideoContainer");
          container.innerHTML = "";
          container.style.display = "none";
          document.getElementById("remoteVideo").style.display = "";
        }

        // Stop ping-pong keepalive
        if (pingInterval) {
          clearInterval(pingInterval);
          pingInterval = null;
        }

        if (ws) {
          try {
            ws.close();
          } catch (e) {}
          ws = null;
        }
        if (pc) {
          try {
            pc.close();
          } catch (e) {}
          pc = null;
        }

        initialOffer = null;
        localCapabilities = null;
        remoteSDP = null;
        rejoinToken = null;
        joinSessionId = null;
        joinCid = null;
        joinVid = null;
        onlineUsers = new Set();
        pendingStreams = {};

        setStatus("stIce", "‚Äî");
        setStatus("stDtls", "‚Äî");
        setStatus("stSignal", "‚Äî");
        setStatus("stConn", "‚Äî");

        document.getElementById("videoOverlay").style.display = "";
        document.getElementById("remoteVideo").srcObject = null;
        document.getElementById("btnConnect").disabled = false;
        document.getElementById("btnConnectSdk").disabled = false;
        document.getElementById("btnDisconnect").disabled = true;

        log("INFO", "Disconnected", "log-info");
      }

      // Save/restore form fields from localStorage
      window.addEventListener("load", () => {
        ["appId", "channelName", "token", "uid"].forEach((id) => {
          const saved = localStorage.getItem("agora_" + id);
          if (saved) document.getElementById(id).value = saved;
        });
      });
      window.addEventListener("beforeunload", () => {
        ["appId", "channelName", "token", "uid"].forEach((id) => {
          localStorage.setItem(
            "agora_" + id,
            document.getElementById(id).value,
          );
        });
      });
    </script>
  </body>
</html>
